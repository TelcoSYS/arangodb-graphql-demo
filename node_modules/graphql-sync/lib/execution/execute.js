
/**
 *  Copyright (c) 2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */

/**
 * Terminology
 *
 * "Definitions" are the generic name for top-level statements in the document.
 * Examples of this include:
 * 1) Operations (such as a query)
 * 2) Fragments
 *
 * "Operations" are a generic name for requests in the document.
 * Examples of this include:
 * 1) query,
 * 2) mutation
 *
 * "Selections" are the statements that can appear legally and at
 * single level of the query. These include:
 * 1) field references e.g "a"
 * 2) fragment "spreads" e.g. "...c"
 * 3) inline fragment "spreads" e.g. "...on Type { a }"
 */

/**
 * Data that must be available at all points during query execution.
 *
 * Namely, schema of the type system that is currently executing,
 * and the fragments defined in the query document
 */
'use strict';

/**
 * The result of execution. `data` is the result of executing the
 * query, `errors` is null if no errors occurred, and is a
 * non-empty array if an error occurred.
 */
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.execute = execute;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _graphqlError = require('graphql/error');

var _graphqlJsutilsFind = require('graphql/jsutils/find');

var _graphqlJsutilsFind2 = _interopRequireDefault(_graphqlJsutilsFind);

var _graphqlJsutilsInvariant = require('graphql/jsutils/invariant');

var _graphqlJsutilsInvariant2 = _interopRequireDefault(_graphqlJsutilsInvariant);

var _graphqlJsutilsIsNullish = require('graphql/jsutils/isNullish');

var _graphqlJsutilsIsNullish2 = _interopRequireDefault(_graphqlJsutilsIsNullish);

var _graphqlUtilitiesTypeFromAST = require('graphql/utilities/typeFromAST');

var _graphqlLanguage = require('graphql/language');

var _graphqlExecutionValues = require('graphql/execution/values');

var _graphqlTypeDefinition = require('graphql/type/definition');

var _graphqlTypeSchema = require('graphql/type/schema');

var _graphqlTypeIntrospection = require('graphql/type/introspection');

var _graphqlTypeDirectives = require('graphql/type/directives');

/**
 * Implements the "Evaluating requests" section of the GraphQL specification.
 *
 * If the arguments to this function do not result in a legal execution context,
 * a GraphQLError will be thrown immediately explaining the invalid input.
 */

function execute(schema, documentAST, rootValue, variableValues, operationName) {
  (0, _graphqlJsutilsInvariant2['default'])(schema, 'Must provide schema');
  (0, _graphqlJsutilsInvariant2['default'])(schema instanceof _graphqlTypeSchema.GraphQLSchema, 'Schema must be an instance of GraphQLSchema. Also ensure that there are ' + 'not multiple versions of GraphQL installed in your node_modules directory.');

  // If a valid context cannot be created due to incorrect arguments,
  // this will throw an error.
  var context = buildExecutionContext(schema, documentAST, rootValue, variableValues, operationName);

  // Return the data described by
  // The "Response" section of the GraphQL specification.
  //
  // If errors are encountered while executing a GraphQL field, only that
  // field and it's descendents will be omitted, and sibling fields will still
  // be executed. An execution which encounters errors will still result in a
  // return value.
  var data;
  try {
    data = executeOperation(context, context.operation, rootValue);
  } catch (error) {
    // Errors from sub-fields of a NonNull type may propagate to the top level,
    // at which point we still log the error and null the parent field, which
    // in this case is the entire response.
    context.errors.push(error);
    data = null;
  }
  if (!context.errors.length) {
    return { data: data };
  }
  return { data: data, errors: context.errors };
}

/**
 * Constructs a ExecutionContext object from the arguments passed to
 * execute, which we will pass throughout the other execution methods.
 *
 * Throws a GraphQLError if a valid execution context cannot be created.
 */
function buildExecutionContext(schema, documentAST, rootValue, rawVariableValues, operationName) {
  var errors = [];
  var operations = {};
  var fragments = {};
  documentAST.definitions.forEach(function (statement) {
    switch (statement.kind) {
      case _graphqlLanguage.Kind.OPERATION_DEFINITION:
        operations[statement.name ? statement.name.value : ''] = statement;
        break;
      case _graphqlLanguage.Kind.FRAGMENT_DEFINITION:
        fragments[statement.name.value] = statement;
        break;
      default:
        throw new _graphqlError.GraphQLError('GraphQL cannot execute a request containing a ' + statement.kind + '.', statement);
    }
  });
  if (!operationName && Object.keys(operations).length !== 1) {
    throw new _graphqlError.GraphQLError('Must provide operation name if query contains multiple operations.');
  }
  var opName = operationName || Object.keys(operations)[0];
  var operation = operations[opName];
  if (!operation) {
    throw new _graphqlError.GraphQLError('Unknown operation named "' + opName + '".');
  }
  var variableValues = (0, _graphqlExecutionValues.getVariableValues)(schema, operation.variableDefinitions || [], rawVariableValues || {});
  var exeContext = { schema: schema, fragments: fragments, rootValue: rootValue, operation: operation, variableValues: variableValues, errors: errors };
  return exeContext;
}

/**
 * Implements the "Evaluating operations" section of the spec.
 */
function executeOperation(exeContext, operation, rootValue) {
  var type = getOperationRootType(exeContext.schema, operation);
  var fields = collectFields(exeContext, type, operation.selectionSet, {}, {});
  if (operation.operation === 'mutation') {
    return executeFieldsSerially(exeContext, type, rootValue, fields);
  }
  return executeFields(exeContext, type, rootValue, fields);
}

/**
 * Extracts the root type of the operation from the schema.
 */
function getOperationRootType(schema, operation) {
  switch (operation.operation) {
    case 'query':
      return schema.getQueryType();
    case 'mutation':
      var mutationType = schema.getMutationType();
      if (!mutationType) {
        throw new _graphqlError.GraphQLError('Schema is not configured for mutations', [operation]);
      }
      return mutationType;
    default:
      throw new _graphqlError.GraphQLError('Can only execute queries and mutations', [operation]);
  }
}

/**
 * Implements the "Evaluating selection sets" section of the spec
 * for "write" mode.
 */
function executeFieldsSerially(exeContext, parentType, sourceValue, fields) {
  return Object.keys(fields).reduce(function (results, responseName) {
    var fieldASTs = fields[responseName];
    var result = resolveField(exeContext, parentType, sourceValue, fieldASTs);
    if (result === undefined) {
      return results;
    }
    results[responseName] = result;
    return results;
  }, {});
}

/**
 * Implements the "Evaluating selection sets" section of the spec
 * for "read" mode.
 */
function executeFields(exeContext, parentType, sourceValue, fields) {
  var finalResults = Object.keys(fields).reduce(function (results, responseName) {
    var fieldASTs = fields[responseName];
    var result = resolveField(exeContext, parentType, sourceValue, fieldASTs);
    if (result === undefined) {
      return results;
    }
    results[responseName] = result;
    return results;
  }, {});

  return finalResults;
}

/**
 * Given a selectionSet, adds all of the fields in that selection to
 * the passed in map of fields, and returns it at the end.
 *
 * CollectFields requires the "runtime type" of an object. For a field which
 * returns and Interface or Union type, the "runtime type" will be the actual
 * Object type returned by that field.
 */
function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (var i = 0; i < selectionSet.selections.length; i++) {
    var selection = selectionSet.selections[i];
    switch (selection.kind) {
      case _graphqlLanguage.Kind.FIELD:
        if (!shouldIncludeNode(exeContext, selection.directives)) {
          continue;
        }
        var name = getFieldEntryKey(selection);
        if (!fields[name]) {
          fields[name] = [];
        }
        fields[name].push(selection);
        break;
      case _graphqlLanguage.Kind.INLINE_FRAGMENT:
        if (!shouldIncludeNode(exeContext, selection.directives) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {
          continue;
        }
        collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
        break;
      case _graphqlLanguage.Kind.FRAGMENT_SPREAD:
        var fragName = selection.name.value;
        if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection.directives)) {
          continue;
        }
        visitedFragmentNames[fragName] = true;
        var fragment = exeContext.fragments[fragName];
        if (!fragment || !shouldIncludeNode(exeContext, fragment.directives) || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {
          continue;
        }
        collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
        break;
    }
  }
  return fields;
}

/**
 * Determines if a field should be included based on the @include and @skip
 * directives, where @skip has higher precidence than @include.
 */
function shouldIncludeNode(exeContext, directives) {
  var skipAST = directives && (0, _graphqlJsutilsFind2['default'])(directives, function (directive) {
    return directive.name.value === _graphqlTypeDirectives.GraphQLSkipDirective.name;
  });
  if (skipAST) {
    var _getArgumentValues = (0, _graphqlExecutionValues.getArgumentValues)(_graphqlTypeDirectives.GraphQLSkipDirective.args, skipAST.arguments, exeContext.variableValues);

    var skipIf = _getArgumentValues['if'];

    return !skipIf;
  }

  var includeAST = directives && (0, _graphqlJsutilsFind2['default'])(directives, function (directive) {
    return directive.name.value === _graphqlTypeDirectives.GraphQLIncludeDirective.name;
  });
  if (includeAST) {
    var _getArgumentValues2 = (0, _graphqlExecutionValues.getArgumentValues)(_graphqlTypeDirectives.GraphQLIncludeDirective.args, includeAST.arguments, exeContext.variableValues);

    var includeIf = _getArgumentValues2['if'];

    return Boolean(includeIf);
  }

  return true;
}

/**
 * Determines if a fragment is applicable to the given type.
 */
function doesFragmentConditionMatch(exeContext, fragment, type) {
  var conditionalType = (0, _graphqlUtilitiesTypeFromAST.typeFromAST)(exeContext.schema, fragment.typeCondition);
  if (conditionalType === type) {
    return true;
  }
  if ((0, _graphqlTypeDefinition.isAbstractType)(conditionalType)) {
    return conditionalType.isPossibleType(type);
  }
  return false;
}

/**
 * Implements the logic to compute the key of a given field’s entry
 */
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}

/**
 * Resolves the field on the given source object. In particular, this
 * figures out the value that the field returns by calling its resolve function,
 * then calls completeValue to serialize scalars, or execute
 * the sub-selection-set for objects.
 */
function resolveField(exeContext, parentType, source, fieldASTs) {
  var fieldAST = fieldASTs[0];
  var fieldName = fieldAST.name.value;

  var fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);
  if (!fieldDef) {
    return;
  }

  var returnType = fieldDef.type;
  var resolveFn = fieldDef.resolve || defaultResolveFn;

  // Build a JS object of arguments from the field.arguments AST, using the
  // variables scope to fulfill any variable references.
  // TODO: find a way to memoize, in case this field is within a List type.
  var args = (0, _graphqlExecutionValues.getArgumentValues)(fieldDef.args, fieldAST.arguments, exeContext.variableValues);

  // The resolve function's optional third argument is a collection of
  // information about the current execution state.
  var info = {
    fieldName: fieldName,
    fieldASTs: fieldASTs,
    returnType: returnType,
    parentType: parentType,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };

  // If an error occurs while calling the field `resolve` function, ensure that
  // it is wrapped as a GraphQLError with locations. Log this error and return
  // null if allowed, otherwise throw the error so the parent field can handle
  // it.
  try {
    var result = resolveFn(source, args, info);
  } catch (error) {
    var reportedError = (0, _graphqlError.locatedError)(error, fieldASTs);
    if (returnType instanceof _graphqlTypeDefinition.GraphQLNonNull) {
      throw reportedError;
    }
    exeContext.errors.push(reportedError);
    return null;
  }

  return completeValueCatchingError(exeContext, returnType, fieldASTs, info, result);
}

function completeValueCatchingError(exeContext, returnType, fieldASTs, info, result) {
  // If the field type is non-nullable, then it is resolved without any
  // protection from errors.
  if (returnType instanceof _graphqlTypeDefinition.GraphQLNonNull) {
    return completeValue(exeContext, returnType, fieldASTs, info, result);
  }

  // Otherwise, error protection is applied, logging the error and resolving
  // a null value for this field if one is encountered.
  try {
    var completed = completeValue(exeContext, returnType, fieldASTs, info, result);
    return completed;
  } catch (error) {
    exeContext.errors.push(error);
    return null;
  }
}

/**
 * Implements the instructions for completeValue as defined in the
 * "Field entries" section of the spec.
 *
 * If the field type is Non-Null, then this recursively completes the value
 * for the inner type. It throws a field error if that completion returns null,
 * as per the "Nullability" section of the spec.
 *
 * If the field type is a List, then this recursively completes the value
 * for the inner type on each item in the list.
 *
 * If the field type is a Scalar or Enum, ensures the completed value is a legal
 * value of the type by calling the `serialize` method of GraphQL type
 * definition.
 *
 * Otherwise, the field type expects a sub-selection set, and will complete the
 * value by evaluating all sub-selections.
 */
function completeValue(exeContext, returnType, fieldASTs, info, result) {
  // If field type is NonNull, complete for inner type, and throw field error
  // if result is null.
  if (returnType instanceof _graphqlTypeDefinition.GraphQLNonNull) {
    var completed = completeValue(exeContext, returnType.ofType, fieldASTs, info, result);
    if (completed === null) {
      throw new _graphqlError.GraphQLError('Cannot return null for non-nullable ' + ('field ' + info.parentType + '.' + info.fieldName + '.'), fieldASTs);
    }
    return completed;
  }

  // If result is null-like, return null.
  if ((0, _graphqlJsutilsIsNullish2['default'])(result)) {
    return null;
  }

  // If field type is List, complete each item in the list with the inner type
  if (returnType instanceof _graphqlTypeDefinition.GraphQLList) {
    (0, _graphqlJsutilsInvariant2['default'])(Array.isArray(result), 'User Error: expected iterable, but did not find one.');

    // This is specified as a simple map.
    var itemType = returnType.ofType;
    var completedResults = result.map(function (item) {
      var completedItem = completeValueCatchingError(exeContext, itemType, fieldASTs, info, item);
      return completedItem;
    });

    return completedResults;
  }

  // If field type is Scalar or Enum, serialize to a valid value, returning
  // null if serialization is not possible.
  if (returnType instanceof _graphqlTypeDefinition.GraphQLScalarType || returnType instanceof _graphqlTypeDefinition.GraphQLEnumType) {
    (0, _graphqlJsutilsInvariant2['default'])(returnType.serialize, 'Missing serialize method on type');
    var serializedResult = returnType.serialize(result);
    return (0, _graphqlJsutilsIsNullish2['default'])(serializedResult) ? null : serializedResult;
  }

  // Field type must be Object, Interface or Union and expect sub-selections.
  var runtimeType;

  if (returnType instanceof _graphqlTypeDefinition.GraphQLObjectType) {
    runtimeType = returnType;
  } else if ((0, _graphqlTypeDefinition.isAbstractType)(returnType)) {
    var abstractType = returnType;
    runtimeType = abstractType.getObjectType(result, info);
    if (runtimeType && !abstractType.isPossibleType(runtimeType)) {
      throw new _graphqlError.GraphQLError('Runtime Object type "' + runtimeType + '" is not a possible type ' + ('for "' + abstractType + '".'), fieldASTs);
    }
  }

  if (!runtimeType) {
    return null;
  }

  // If there is an isTypeOf predicate function, call it with the
  // current result. If isTypeOf returns false, then raise an error rather
  // than continuing execution.
  if (runtimeType.isTypeOf && !runtimeType.isTypeOf(result, info)) {
    throw new _graphqlError.GraphQLError('Expected value of type "' + runtimeType + '" but got: ' + result + '.', fieldASTs);
  }

  // Collect sub-fields to execute to complete this value.
  var subFieldASTs = {};
  var visitedFragmentNames = {};
  for (var i = 0; i < fieldASTs.length; i++) {
    var selectionSet = fieldASTs[i].selectionSet;
    if (selectionSet) {
      subFieldASTs = collectFields(exeContext, runtimeType, selectionSet, subFieldASTs, visitedFragmentNames);
    }
  }

  return executeFields(exeContext, runtimeType, result, subFieldASTs);
}

/**
 * If a resolve function is not given, then a default resolve behavior is used
 * which takes the property of the source object of the same name as the field
 * and returns it as the result, or if it's a function, returns the result
 * of calling that function.
 */
function defaultResolveFn(source, args, _ref) {
  var fieldName = _ref.fieldName;

  var property = source[fieldName];
  return typeof property === 'function' ? property.call(source) : property;
}

/**
 * This method looks up the field on the given type defintion.
 * It has special casing for the two introspection fields, __schema
 * and __typename. __typename is special because it can always be
 * queried as a field, even in situations where no other fields
 * are allowed, like on a Union. __schema could get automatically
 * added to the query type, but that would require mutating type
 * definitions, which would cause issues.
 */
function getFieldDef(schema, parentType, fieldName) {
  if (fieldName === _graphqlTypeIntrospection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return _graphqlTypeIntrospection.SchemaMetaFieldDef;
  } else if (fieldName === _graphqlTypeIntrospection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return _graphqlTypeIntrospection.TypeMetaFieldDef;
  } else if (fieldName === _graphqlTypeIntrospection.TypeNameMetaFieldDef.name) {
    return _graphqlTypeIntrospection.TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}